import { NextRequest, NextResponse } from "next/server";
import { connectToDatabase } from "@/lib/mongodb";
import GameModel from "@/models/Game";
import { currentUser } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { getModelForUser, incrementApiUsage } from "@/lib/modelSelection";
import { callOpenAIChat, performAiReviewCycle, AiReviewCycleRawOutputs } from "@/lib/aiService"; // Import shared functions
import { ChatCompletionMessageParam, ChatCompletionSystemMessageParam } from "openai/resources/chat/completions";


const FALLBACK_SYSTEM_PROMPT_TEMPLATE = `
You are an AI assistant specialized in creating custom surveys for the RandomPlayables platform.
You help users design effective surveys, questionnaires, and data collection tools that can
optionally incorporate interactive games.

Available games that can be integrated into surveys:
%%AVAILABLE_GAMES_LIST%%

When helping design surveys:
1. Ask clarifying questions about the user's research goals and target audience
2. Suggest appropriate question types (multiple choice, Likert scale, open-ended, etc.)
3. Help write clear, unbiased questions
4. Recommend game integration where appropriate for engagement or data collection
5. Advise on survey flow and organization

When designing a survey with game integration:
1. Explain how the game data will complement traditional survey questions
2. Discuss how to interpret combined qualitative and quantitative results
3. Suggest appropriate placement of games within the survey flow

Return your suggestions in a clear, structured format. If suggesting multiple questions,
number them and specify the question type for each.
`;

async function fetchActiveGamesList() {
  await connectToDatabase();
  const games = await GameModel.find({}, {
    id: 1, name: 1, description: 1, _id: 0
  }).limit(10).lean();
  return games;
}

export async function POST(request: NextRequest) {
  try {
    const clerkUser = await currentUser();
    if (!clerkUser || !clerkUser.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { message: userQuery, chatHistory, customSystemPrompt, useCodeReview } = await request.json();

    const profile = await prisma.profile.findUnique({
        where: { userId: clerkUser.id },
        select: { subscriptionActive: true },
    });
    const isSubscribed = profile?.subscriptionActive || false;

    let finalSystemPrompt: string;
    const games = await fetchActiveGamesList();
    const gamesListString = JSON.stringify(games, null, 2);

    if (customSystemPrompt && customSystemPrompt.trim() !== "") {
      finalSystemPrompt = customSystemPrompt;
      if (finalSystemPrompt.includes("%%AVAILABLE_GAMES_LIST%%")) {
        finalSystemPrompt = finalSystemPrompt.replace("%%AVAILABLE_GAMES_LIST%%", gamesListString);
      }
    } else {
      finalSystemPrompt = FALLBACK_SYSTEM_PROMPT_TEMPLATE.replace("%%AVAILABLE_GAMES_LIST%%", gamesListString);
    }

    let finalApiResponse: { message: string; remainingRequests?: number; };

    const initialUserMessages: ChatCompletionMessageParam[] = [
        ...(chatHistory.map((msg: any) => ({ role: msg.role, content: msg.content })) as ChatCompletionMessageParam[]),
        { role: "user", content: userQuery }
    ];
    const systemMessage: ChatCompletionSystemMessageParam = { role: "system", content: finalSystemPrompt };

    if (useCodeReview) {
      const chatbot1Model = isSubscribed ? "openai/o4-mini-high" : "meta-llama/llama-3.3-8b-instruct:free";
      const chatbot2Model = isSubscribed ? "google/gemini-2.5-flash-preview-05-20" : "deepseek/deepseek-r1-0528:free";

      const createReviewerPrompt = (initialSurveyDesign: string | null): string => `
        You are an expert survey design reviewer. Review the following survey design generated by Chatbot1.
        The survey is for the RandomPlayables platform and may involve game integrations.
        Please look for:
        - Clarity and effectiveness of questions.
        - Appropriateness of question types (multiple choice, Likert, text, game integration).
        - Logical flow and organization of the survey.
        - Potential biases in questions.
        - Soundness of game integration logic, if proposed.
        - Completeness based on the user's request.
        - Adherence to the system prompt provided to Chatbot1.

        Provide concise and actionable feedback for improving the survey design.

        Original User Prompt to Chatbot1:
        ---
        ${userQuery}
        ---

        System Prompt used for Chatbot1:
        ---
        ${finalSystemPrompt}
        ---

        Survey Design generated by Chatbot1:
        ---
        ${initialSurveyDesign || "Chatbot1 did not provide an initial survey design."}
        ---
        Your review:
      `;

      const createRevisionPrompt = (initialSurveyDesign: string | null, reviewFromChatbot2: string | null): string => `
        You are an AI assistant that generated the initial survey design below.
        Another AI (Chatbot2) has reviewed your design and provided feedback.
        Please carefully consider the feedback and revise your original survey design.
        Ensure the revised design still accurately addresses the original user prompt and adheres to ALL requirements in the original system prompt.
        Return the complete, revised survey design.

        Original User Prompt:
        ---
        ${userQuery}
        ---

        Original System Prompt You Followed:
        ---
        ${finalSystemPrompt}
        ---

        Your Initial Survey Design:
        ---
        ${initialSurveyDesign || "No initial survey design was provided."}
        ---

        Chatbot2's Review of Your Design:
        ---
        ${reviewFromChatbot2 || "No review feedback provided."}
        ---

        Your Revised Survey Design:
      `;

      const reviewCycleOutputs: AiReviewCycleRawOutputs = await performAiReviewCycle(
        chatbot1Model,
        systemMessage,
        initialUserMessages,
        chatbot2Model,
        createReviewerPrompt,
        createRevisionPrompt
      );

      finalApiResponse = {
        message: reviewCycleOutputs.chatbot1RevisionResponse.content ||
                   reviewCycleOutputs.chatbot1InitialResponse.content ||
                   "Could not generate a revised response.",
      };

    } else {
      const { model, canUseApi, remainingRequests: modelSelectionRemaining } = await getModelForUser(clerkUser.id);

      if (!canUseApi) {
        return NextResponse.json({
          error: "Monthly API request limit reached. Please upgrade your plan for more requests.",
          limitReached: true
        }, { status: 403 });
      }

      const messagesToAI: ChatCompletionMessageParam[] = [systemMessage, ...initialUserMessages];
      const response = await callOpenAIChat(model, messagesToAI);

      finalApiResponse = {
        message: response.choices[0].message.content || "Could not generate a response.",
        remainingRequests: modelSelectionRemaining
      };
    }

    await incrementApiUsage(clerkUser.id);
    const usageData = await prisma.apiUsage.findUnique({ where: { userId: clerkUser.id } });
    const remainingRequestsAfterIncrement = Math.max(0, (usageData?.monthlyLimit || 0) - (usageData?.usageCount || 0));
    finalApiResponse.remainingRequests = remainingRequestsAfterIncrement;

    return NextResponse.json(finalApiResponse);

  } catch (error: any) {
    console.error("Error in Collect chat:", error);
    let errorDetails = error.message;
    if (error.response && error.response.data && error.response.data.error) {
        errorDetails = error.response.data.error.message || error.message;
    }
    return NextResponse.json(
      { error: "Failed to generate survey suggestion", details: errorDetails, stack: error.stack },
      { status: 500 }
    );
  }
}